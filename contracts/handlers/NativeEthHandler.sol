pragma solidity 0.6.4;
//pragma experimental ABIEncoderV2;
//
//import "../interfaces/IDepositExecute.sol";
//import "./HandlerHelpers.sol";
//import "../ERC20Safe.sol";
//import "@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol";
//import "../interfaces/IERC20Permit.sol";
//
///**
//    @title Handles ERC20 deposits and deposit executions.
//    @author ChainSafe Systems.
//    @notice This contract is intended to be used with the Bridge contract.
// */
//contract NativeEthHandler is IDepositExecute {
////    struct DepositRecord {
////        address _tokenAddress;
////        uint8 _lenDestinationRecipientAddress;
////        uint8 _destinationChainID;
////        bytes32 _resourceID;
////        bytes _destinationRecipientAddress;
////        address _depositer;
////        uint _amount;
////    }
//
//    struct DepositRecord {
//        uint8   _destinationChainID;
//        address _depositer;
//        bytes32 _resourceID;
//        bytes   _metaData;
//    }
//
//    address public _bridgeAddress;
//
//    // depositNonce => Deposit Record
//    mapping(uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;
//
//    // resourceID => contract address
//    mapping (bytes32 => address) public _resourceIDToContractAddress;
//
//    // contract address => resourceID
//    mapping (address => bytes32) public _contractAddressToResourceID;
//
//    // contract address => deposit function signature
//    mapping (address => bytes4) public _contractAddressToDepositFunctionSignature;
//
//    // contract address => execute proposal function signature
//    mapping (address => bytes4) public _contractAddressToExecuteFunctionSignature;
//
//    // token contract address => is whitelisted
//    mapping (address => bool) public _contractWhitelist;
//
//    modifier onlyBridge() {
//        _onlyBridge();
//        _;
//    }
//
//    function _onlyBridge() private {
//        require(msg.sender == _bridgeAddress, "sender must be bridge contract");
//    }
//
//    constructor(
//        address bridgeAddress,
//        bytes32[] memory initialResourceIDs,
//        address[] memory initialContractAddresses,
//        bytes4[]  memory initialDepositFunctionSignatures,
//        bytes4[]  memory initialExecuteFunctionSignatures
//    ) public {
//        require(initialResourceIDs.length == initialContractAddresses.length,
//            "initialResourceIDs and initialContractAddresses len mismatch");
//
//        require(initialContractAddresses.length == initialDepositFunctionSignatures.length,
//            "provided contract addresses and function signatures len mismatch");
//
//        require(initialDepositFunctionSignatures.length == initialExecuteFunctionSignatures.length,
//            "provided deposit and execute function signatures len mismatch");
//
//        _bridgeAddress = bridgeAddress;
//
//        for (uint256 i = 0; i < initialResourceIDs.length; i++) {
//            _setResource(
//                initialResourceIDs[i],
//                initialContractAddresses[i],
//                initialDepositFunctionSignatures[i],
//                initialExecuteFunctionSignatures[i]);
//        }
//    }
//
//    /**
//        @notice First verifies {_resourceIDToContractAddress}[{resourceID}] and
//        {_contractAddressToResourceID}[{contractAddress}] are not already set,
//        then sets {_resourceIDToContractAddress} with {contractAddress},
//        {_contractAddressToResourceID} with {resourceID},
//        {_contractAddressToDepositFunctionSignature} with {depositFunctionSig},
//        {_contractAddressToExecuteFunctionSignature} with {executeFunctionSig},
//        and {_contractWhitelist} to true for {contractAddress}.
//        @param resourceID ResourceID to be used when making deposits.
//        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
//        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.
//        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.
//     */
//    function setResource(
//        bytes32 resourceID,
//        address contractAddress,
//        bytes4 depositFunctionSig,
//        bytes4 executeFunctionSig
//    ) external onlyBridge {
//
//        _setResource(resourceID, contractAddress, depositFunctionSig, executeFunctionSig);
//    }
//
//    /**
//        @param depositNonce This ID will have been generated by the Bridge contract.
//        @param destId ID of chain deposit will be bridged to.
//        @return DepositRecord which consists of:
//        - _tokenAddress Address used when {deposit} was executed.
//        - _destinationChainID ChainID deposited tokens are intended to end up on.
//        - _resourceID ResourceID used when {deposit} was executed.
//        - _lenDestinationRecipientAddress Used to parse recipient's address from {_destinationRecipientAddress}
//        - _destinationRecipientAddress Address tokens are intended to be deposited to on desitnation chain.
//        - _depositer Address that initially called {deposit} in the Bridge contract.
//        - _amount Amount of tokens that were deposited.
//    */
//    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {
//        return _depositRecords[destId][depositNonce];
//    }
//
//    /**
//        @notice A deposit is initiatied by making a deposit in the Bridge contract.
//        @param destinationChainID Chain ID of chain tokens are expected to be bridged to.
//        @param depositNonce This value is generated as an ID by the Bridge contract.
//        @param depositer Address of account making the deposit in the Bridge contract.
//        @param data Consists of: {resourceID}, {amount}, {lenRecipientAddress}, and {recipientAddress}
//        all padded to 32 bytes.
//        @notice Data passed into the function should be constructed as follows:
//        amount                      uint256     bytes   0 - 32
//        recipientAddress length     uint256     bytes  32 - 64
//        recipientAddress            bytes       bytes  64 - END
//        @dev Depending if the corresponding {tokenAddress} for the parsed {resourceID} is
//        marked true in {_burnList}, deposited tokens will be burned, if not, they will be locked.
//     */
//    function deposit(
//        bytes32 resourceID,
//        uint8 destinationChainID,
//        uint64 depositNonce,
//        address depositer,
//        bytes   calldata data
//    ) external override onlyBridge {
//        bytes memory recipientAddress;
//        uint256 amount;
//        uint256 lenRecipientAddress;
//
////        assembly {
////
////            amount := calldataload(0xC4)
////
////            recipientAddress := mload(0x40)
////            lenRecipientAddress := calldataload(0xE4)
////            mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))
////
////            calldatacopy(
////                recipientAddress, // copy to destinationRecipientAddress
////                0xE4, // copy from calldata @ 0x104
////                sub(calldatasize(), 0xE) // copy size (calldatasize - 0x104)
////            )
////        }
//
//        address _recipientAddress;
//        (amount, lenRecipientAddress, _recipientAddress) = abi.decode(data, (uint256, uint256, address));
//        recipientAddress = abi.encodePacked(_recipientAddress);
//
//        address contractAddress = _resourceIDToContractAddress[resourceID];
//        require(_contractWhitelist[contractAddress], "provided tokenAddress is not whitelisted");
//
////        if (_burnList[tokenAddress]) {
////            burnERC20(tokenAddress, depositer, amount);
////        } else {
////            lockERC20(tokenAddress, depositer, address(this), amount);
////        }
//
//
//        bytes4 sig = _contractAddressToDepositFunctionSignature[contractAddress];
//        if (sig != bytes4(0)) {
//            bytes memory callData = abi.encodePacked(sig, data);
//            (bool success,) = contractAddress.call(callData);
//            require(success, "delegatecall to contractAddress failed");
//        }
//
////        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
////            contractAddress,
////            uint8(lenRecipientAddress),
////            destinationChainID,
////            resourceID,
////            recipientAddress,
////            depositer,
////            amount
////        );
//
//        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
//            destinationChainID,
//            depositer,
//            resourceID,
//            data
//        );
//    }
//
//
//    address __depositer;
//
//    function __getDepositer() public view returns (address) {
//        return __depositer;
//    }
//
//    uint8 __v;
//
//    function __getV() public view returns (uint8) {
//        return __v;
//    }
//
//    bytes32 __r;
//
//    function __getR() public view returns (bytes32) {
//        return __r;
//    }
//
//    bytes32 __s;
//
//    function __getS() public view returns (bytes32) {
//        return __s;
//    }
//
//    bytes __recipientAddress;
//
//    function __getRecipientAddress() public view returns (bytes memory) {
//        return __recipientAddress;
//    }
//
//
//    uint256 __ammount;
//
//    function __getAmount() public view returns (uint256) {
//        return __ammount;
//    }
//
//    uint256 __deadline;
//
//    function __getDeadline() public view returns (uint256) {
//        return __deadline;
//    }
//
//    uint8 __lenDestinationRecipientAddress;
//
//    function __getLenDestinationRecipientAddress() public view returns (uint256) {
//        return __lenDestinationRecipientAddress;
//    }
//
//
//    function depositWithPermit(
//        bytes32 resourceID,
//        uint8 destinationChainID,
//        uint64 depositNonce,
//        address depositer,
//        bytes   calldata data
//
//    ) external override onlyBridge {
//        bytes memory recipientAddress;
//        uint256 amount;
//        uint256 lenRecipientAddress;
//        address contractAddress = _resourceIDToContractAddress[resourceID];
//
//        {
//
//            /*
//    //        assembly {
//    //
//    //            amount := calldataload(0xC4)
//    //
//    //            recipientAddress := mload(0x40)
//    //            lenRecipientAddress := calldataload(0xE4)
//    //            mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))
//    //
//    //            calldatacopy(
//    //            recipientAddress, // copy to destinationRecipientAddress
//    //            0xE4, // copy from calldata @ 0x104
//    //            sub(calldatasize(), 0xE) // copy size (calldatasize - 0x104)
//    //            )
//    //        }
//    //            assembly {
//    //
//    //                deadline := calldataload(0xC4)
//    //                _v := calldataload(0xE4)
//    //                _r := calldataload(0x104)
//    //                _s := calldataload(0x124)
//    //                amount := calldataload(0x144)
//    //
//    //                recipientAddress := mload(0x40)
//    //                lenRecipientAddress := calldataload(0x164)
//    //                mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))
//    //
//    //                calldatacopy(
//    //                recipientAddress, // copy to destinationRecipientAddress
//    //                0x164, // copy from calldata @ 0x104
//    //                sub(calldatasize(), 0x104) // copy size (calldatasize - 0x104)
//    //                )
//    //            }
//*/
//
//            address _recipientAddress;
//            {
//                uint256 deadline;
//                uint256 _v;
//                uint256 _r;
//                uint256 _s;
//
//
//                (amount, lenRecipientAddress, _recipientAddress, deadline, _v, _r, _s) =
//                abi.decode(data, (uint256, uint256, address, uint256, uint256, uint256, uint256));
//
//                recipientAddress = abi.encodePacked(_recipientAddress);
//                __recipientAddress = recipientAddress;
//                __ammount = amount;
//                __deadline = deadline;
//                __v = uint8(_v);
//                __r = bytes32(_r);
//                __s = bytes32(_s);
//                __lenDestinationRecipientAddress = uint8(lenRecipientAddress);
//                require(_contractWhitelist[contractAddress], "provided tokenAddress is not whitelisted");
//
////                IERC20Permit erc20 = IERC20Permit(tokenAddress);
////                erc20.permit(depositer, address(this), amount, deadline, uint8(_v), bytes32(_r), bytes32(_s));
//            }
//
////            if (_burnList[tokenAddress]) {
////                burnERC20(tokenAddress, depositer, amount);
////            } else {
////                lockERC20(tokenAddress, depositer, address(this), amount);
////            }
//
//            bytes4 sig = _contractAddressToDepositFunctionSignature[contractAddress];
//            if (sig != bytes4(0)) {
//                bytes memory callData = abi.encodePacked(sig, data);
//                (bool success,) = contractAddress.call(callData);
//                require(success, "delegatecall to contractAddress failed");
//            }
//
//
////           _depositRecords[destinationChainID][depositNonce] = DepositRecord(
////                contractAddress,
////                uint8(lenRecipientAddress),
////                destinationChainID,
////                resourceID,
////                recipientAddress,
////                depositer,
////                amount
////            );
//
//            _depositRecords[destinationChainID][depositNonce] = DepositRecord(
//                destinationChainID,
//                depositer,
//                resourceID,
//                data
//            );
//
//        }
//    }
//
//    /**
//        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
//        by a relayer on the deposit's destination chain.
//        @param data Consists of {resourceID}, {amount}, {lenDestinationRecipientAddress},
//        and {destinationRecipientAddress} all padded to 32 bytes.
//        @notice Data passed into the function should be constructed as follows:
//        amount                                 uint256     bytes  0 - 32
//        destinationRecipientAddress length     uint256     bytes  32 - 64
//        destinationRecipientAddress            bytes       bytes  64 - END
//     */
//    function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {
////        uint256 amount;
////        uint256 lenRecipientAddress;
//        //bytes  memory destinationRecipientAddress;
//
////        assembly {
////            amount := calldataload(0x64)
////
////            destinationRecipientAddress := mload(0x40)
////            let lenDestinationRecipientAddress := calldataload(0x84)
////            mstore(0x40, add(0x20, add(destinationRecipientAddress, lenDestinationRecipientAddress)))
////
////        // in the calldata the destinationRecipientAddress is stored at 0xC4 after accounting for the function signature and length declaration
////            calldatacopy(
////                destinationRecipientAddress, // copy to destinationRecipientAddress
////                0x84, // copy from calldata @ 0x84
////                sub(calldatasize(), 0x84) // copy size to the end of calldata
////            )
////        }
//
//        uint256       amount;
//        uint256       lenDestinationRecipientAddress;
//        bytes  memory destinationRecipientAddress;
//
//        address _recipientAddress;
//        (amount, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));
//        destinationRecipientAddress = bytes(data[64:64 + lenDestinationRecipientAddress]);
//
//        bytes20 recipientAddress;
//        address contractAddress = _resourceIDToContractAddress[resourceID];
//
//        assembly {
//            recipientAddress := mload(add(destinationRecipientAddress, 0x20))
//        }
//
//        require(_contractWhitelist[contractAddress], "provided tokenAddress is not whitelisted");
//
////        if (_burnList[tokenAddress]) {
////            mintERC20(tokenAddress, address(recipientAddress), amount);
////        } else {
////            releaseERC20(tokenAddress, address(recipientAddress), amount);
////        }
//
//        require(_contractWhitelist[contractAddress], "provided contractAddress is not whitelisted");
//
//        bytes4 sig = _contractAddressToExecuteFunctionSignature[contractAddress];
//        if (sig != bytes4(0)) {
//            bytes memory callData = abi.encodePacked(sig, data);
//            (bool success,) = contractAddress.call(callData);
//            require(success, "delegatecall to contractAddress failed");
//        }
//    }
//
//    function _setResource(
//        bytes32 resourceID,
//        address contractAddress,
//        bytes4 depositFunctionSig,
//        bytes4 executeFunctionSig
//    ) internal {
//        _resourceIDToContractAddress[resourceID] = contractAddress;
//        _contractAddressToResourceID[contractAddress] = resourceID;
//        _contractAddressToDepositFunctionSignature[contractAddress] = depositFunctionSig;
//        _contractAddressToExecuteFunctionSignature[contractAddress] = executeFunctionSig;
//
//        _contractWhitelist[contractAddress] = true;
//    }
//
//}
